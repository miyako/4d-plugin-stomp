/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : STOMP
 #	author : miyako
 #	2017/05/21
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark ctx ref

typedef struct
{
	apr_pool_t *pool;
	stomp_connection *connection;
} stomp_ctx;

std::map<uint32_t, stomp_ctx*> stomp_contexts;

uint32_t stomp_context_add(stomp_connection *connection, apr_pool_t *pool)
{
	stomp_ctx *ctx = new stomp_ctx;
	ctx->connection = connection;
	ctx->pool = pool;
	
	uint32_t i = 1;
	
	while (stomp_contexts.find(i) != stomp_contexts.end()) i++;
	
	stomp_contexts.insert(std::map<uint32_t, stomp_ctx*>::value_type(i, ctx));
	
	return i;
}

stomp_ctx *stomp_context_get(uint32_t i)
{
	stomp_ctx *ctx = NULL;
	
	std::map<uint32_t, stomp_ctx*>::iterator pos = stomp_contexts.find(i);
	
	if(pos != stomp_contexts.end()) ctx = pos->second;
	
	return ctx;
}

void stomp_context_remove(uint32_t i)
{
	stomp_ctx *ctx = NULL;
	
	std::map<uint32_t, stomp_ctx*>::iterator pos = stomp_contexts.find(i);
	
	if(pos != stomp_contexts.end())
	{
		ctx = pos->second;
		delete ctx;
		stomp_contexts.erase(pos);
	}
}

#pragma mark frame header

typedef struct
{
	ARRAY_TEXT *headerNames;
	ARRAY_TEXT *headerValues;
}frame_header;

int get_frame_header(void *rec, const void *key, apr_ssize_t klen, const void *value)
{
	frame_header *f = (frame_header *)rec;
	CUTF8String headerName, headerValue;
	headerName = CUTF8String((const uint8_t *)key, klen);
	headerValue = CUTF8String((const uint8_t *)value);
	f->headerNames->appendUTF8String(&headerName);
	f->headerValues->appendUTF8String(&headerValue);
	
	return 1;
}

#pragma mark Startup / Exit

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnExit()
{
	for(std::map<uint32_t, stomp_ctx*>::iterator i = stomp_contexts.begin(); i != stomp_contexts.end(); i++)
	{
		stomp_ctx *ctx = i->second;
		delete ctx;
	}
	stomp_contexts.clear();
	
	apr_terminate();
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		OnExit();
	}
}

void OnStartup()
{
	apr_initialize();
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			// --- STOMP

		case 1 :
			STOMP_Connect(pResult, pParams);
			break;

		case 2 :
			STOMP_Read(pResult, pParams);
			break;

		case 3 :
			STOMP_Write(pResult, pParams);
			break;

		case 4 :
			STOMP_Disconnect(pResult, pParams);
			break;

	}
}

#pragma mark -

// ------------------------------------- STOMP ------------------------------------

void STOMP_Connect(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_host;
	C_LONGINT Param2_port;
	C_LONGINT returnValue;

	Param1_host.fromParamAtIndex(pParams, 1);
	Param2_port.fromParamAtIndex(pParams, 2);

	const char *hostname;
	int port;
	CUTF8String _hostname;
	Param1_host.copyUTF8String(&_hostname);
	hostname = (const char *)_hostname.c_str();
	port = Param2_port.getIntValue();
	
	// --- write the code of STOMP_Connect here...
	
	apr_status_t rc;
	apr_pool_t *pool;
	stomp_connection *connection;
	
	rc = apr_pool_create(&pool, NULL);
	if (rc == APR_SUCCESS)
	{
		rc = stomp_connect(&connection, hostname, port, pool);
		if(rc == APR_SUCCESS)
		{
			returnValue.setIntValue(stomp_context_add(connection, pool));
		}else
		{
			returnValue.setIntValue(-rc);
		}
	}else
	{
		returnValue.setIntValue(-rc);
	}

	returnValue.setReturn(pResult);
}

void STOMP_Read(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT Param2_command;
	C_TEXT Param3_body;
	ARRAY_TEXT Param4_headerNames;
	ARRAY_TEXT Param5_headerValues;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	// --- write the code of STOMP_Read here...

	apr_status_t rc;
	
	stomp_ctx *ctx = stomp_context_get(Param1.getIntValue());
	
	if(ctx)
	{
		stomp_frame *frame;
		
		rc = stomp_read(ctx->connection, &frame, ctx->pool);
		if(rc == APR_SUCCESS)
		{
			CUTF8String _command = CUTF8String((const uint8_t *)frame->command);
			CUTF8String _body = CUTF8String((const uint8_t *)frame->body, frame->body_length == -1 ? 0 : frame->body_length);
			
			Param2_command.setUTF8String(&_command);
			Param3_body.setUTF8String(&_body);
			
			apr_hash_t *headers = frame->headers;
			if(apr_hash_count(headers))
			{
				Param4_headerNames.setSize(1);
				Param5_headerValues.setSize(1);
				frame_header f;
				f.headerNames = &Param4_headerNames;
				f.headerValues = &Param5_headerValues;
				apr_hash_do(get_frame_header, &f, headers);
			}
			
		}else
		{
			returnValue.setIntValue(-rc);
		}
		
	}else
	{
		returnValue.setIntValue(-1);
	}
	
	Param2_command.toParamAtIndex(pParams, 2);
	Param3_body.toParamAtIndex(pParams, 3);
	Param4_headerNames.toParamAtIndex(pParams, 4);
	Param5_headerValues.toParamAtIndex(pParams, 5);
	returnValue.setReturn(pResult);
}

void STOMP_Write(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT Param2_command;
	C_TEXT Param3_body;
	ARRAY_TEXT Param4_headerNames;
	ARRAY_TEXT Param5_headerValues;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2_command.fromParamAtIndex(pParams, 2);
	Param3_body.fromParamAtIndex(pParams, 3);
	Param4_headerNames.fromParamAtIndex(pParams, 4);
	Param5_headerValues.fromParamAtIndex(pParams, 5);

	char *command, *body;
	CUTF8String _command, _body;
	Param2_command.copyUTF8String(&_command);
	Param3_body.copyUTF8String(&_body);
	command = (char *)_command.c_str();
	body = (char *)_body.c_str();
	
	// --- write the code of STOMP_Write here...

	apr_status_t rc;
	
	stomp_ctx *ctx = stomp_context_get(Param1.getIntValue());
	
	if(ctx)
	{
		stomp_frame frame;
		
		frame.command = command;
		frame.body = _body.length() ? body : NULL;
		frame.body_length = _body.length(); //not using -1 (strlen)
		frame.headers = apr_hash_make(ctx->pool);
		
		bool withHeaders = false;
		
		if(Param4_headerNames.getSize() == Param5_headerValues.getSize())
		{
			CUTF8String headerName, headerValue;
			for(unsigned int i = 0; i < Param4_headerNames.getSize(); ++i)
			{
				Param4_headerNames.copyUTF8StringAtIndex(&headerName, i);
				Param5_headerValues.copyUTF8StringAtIndex(&headerValue, i);
				if(headerName.length())
				{
					apr_hash_set(frame.headers, headerName.c_str(), APR_HASH_KEY_STRING, headerValue.c_str());
					withHeaders = true;
				}
			}
		}
		if(!withHeaders)
		{
			frame.headers = NULL;
		}
		
		rc = stomp_write(ctx->connection, &frame, ctx->pool);
		
		returnValue.setIntValue(-rc);
		
	}else
	{
		returnValue.setIntValue(-1);
	}
	
	returnValue.setReturn(pResult);
}

void STOMP_Disconnect(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	// --- write the code of STOMP_Disconnect here...
	
	stomp_ctx *ctx = stomp_context_get(Param1.getIntValue());

	if(ctx)
	{
		returnValue.setIntValue(stomp_disconnect(&ctx->connection));
		stomp_context_remove(Param1.getIntValue());
	}else
	{
		returnValue.setIntValue(-1);
	}
	
	returnValue.setReturn(pResult);
}

