/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-STOMP.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : STOMP
 #	author : miyako
 #	2019/07/06
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-STOMP.h"

std::mutex globalMutex;

#pragma mark ctx

typedef struct {

    apr_pool_t *pool;
    stomp_connection *connection;
} stomp_ctx;

std::map<uint32_t, stomp_ctx*> stomp_contexts;

uint32_t stomp_context_add(stomp_connection *connection, apr_pool_t *pool) {
    
    std::lock_guard<std::mutex> lock(globalMutex);
    
    stomp_ctx *ctx = new stomp_ctx;
    ctx->connection = connection;
    ctx->pool = pool;
    
    uint32_t i = 1;
    
    while (stomp_contexts.find(i) != stomp_contexts.end()) i++;
    
    stomp_contexts.insert(std::map<uint32_t, stomp_ctx*>::value_type(i, ctx));
    
    return i;
}

stomp_ctx *stomp_context_get(uint32_t i) {
    
    std::lock_guard<std::mutex> lock(globalMutex);
    
    stomp_ctx *ctx = NULL;
    
    std::map<uint32_t, stomp_ctx*>::iterator pos = stomp_contexts.find(i);
    
    if(pos != stomp_contexts.end()) ctx = pos->second;
    
    return ctx;
}

void stomp_context_remove(uint32_t i) {
    
    std::lock_guard<std::mutex> lock(globalMutex);
    
    stomp_ctx *ctx = NULL;
    
    std::map<uint32_t, stomp_ctx*>::iterator pos = stomp_contexts.find(i);
    
    if(pos != stomp_contexts.end())
    {
        ctx = pos->second;
        delete ctx;
        stomp_contexts.erase(pos);
    }
}

#pragma mark frame header

typedef struct {
    
    ARRAY_TEXT *headerNames;
    ARRAY_TEXT *headerValues;
}frame_header;

int get_frame_header(void *rec, const void *key, apr_ssize_t klen, const void *value) {
    
    frame_header *f = (frame_header *)rec;
    CUTF8String headerName, headerValue;
    headerName = CUTF8String((const uint8_t *)key, klen);
    headerValue = CUTF8String((const uint8_t *)value);
    f->headerNames->appendUTF8String(&headerName);
    f->headerValues->appendUTF8String(&headerValue);
    
    return 1;
}

#pragma mark Startup / Exit

void OnExit()
{
    for(std::map<uint32_t, stomp_ctx*>::iterator i = stomp_contexts.begin(); i != stomp_contexts.end(); i++)
    {
        stomp_ctx *ctx = i->second;
        delete ctx;
    }
    stomp_contexts.clear();
    
    apr_terminate();
}

void OnStartup()
{
    apr_initialize();
}

#pragma mark -
#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
                // --- STOMP
             
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
                OnExit();
                break;
                
            case 1 :
                STOMP_Connect(params);
                break;
            case 2 :
                STOMP_Read(params);
                break;
            case 3 :
                STOMP_Write(params);
                break;
            case 4 :
                STOMP_Disconnect(params);
                break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void STOMP_Read(PA_PluginParameters params) {

    C_TEXT Param2_command;
    C_TEXT Param3_body;
    ARRAY_TEXT Param4_headerNames;
    ARRAY_TEXT Param5_headerValues;

    apr_interval_time_t timeout = (apr_interval_time_t)
    ((unsigned int)PA_GetLongParameter(params, 6));
    
    timeout = timeout ? timeout : 3000;
    
    apr_status_t rc;
    
    PA_long32 ctxId = PA_GetLongParameter(params, 1);
    stomp_ctx *ctx = stomp_context_get(ctxId);
    
    if(ctx)
    {
        stomp_frame *frame;
        
        apr_socket_timeout_set(ctx->connection->socket, timeout * 1000);
        
        rc = stomp_read(ctx->connection, &frame, ctx->pool);
        if(rc == APR_SUCCESS)
        {
            CUTF8String _command = CUTF8String((const uint8_t *)frame->command);
            CUTF8String _body = CUTF8String((const uint8_t *)frame->body, frame->body_length == -1 ? 0 : frame->body_length);
            
            Param2_command.setUTF8String(&_command);
            Param3_body.setUTF8String(&_body);
            
            apr_hash_t *headers = frame->headers;
            if(apr_hash_count(headers))
            {
                Param4_headerNames.setSize(1);
                Param5_headerValues.setSize(1);
                frame_header f;
                f.headerNames = &Param4_headerNames;
                f.headerValues = &Param5_headerValues;
                apr_hash_do(get_frame_header, &f, headers);
            }
            
        }
        PA_ReturnLong(params, -rc);
        
    }else
    {
        PA_ReturnLong(params, -1);
    }
    
    Param2_command.toParamAtIndex((PackagePtr)params->fParameters, 2);
    Param3_body.toParamAtIndex((PackagePtr)params->fParameters, 3);
    Param4_headerNames.toParamAtIndex((PackagePtr)params->fParameters, 4);
    Param5_headerValues.toParamAtIndex((PackagePtr)params->fParameters, 5);
}

void STOMP_Write(PA_PluginParameters params) {

    C_TEXT Param2_command;
    C_TEXT Param3_body;
    ARRAY_TEXT Param4_headerNames;
    ARRAY_TEXT Param5_headerValues;

    Param2_command.fromParamAtIndex((PackagePtr)params->fParameters, 2);
    Param3_body.fromParamAtIndex((PackagePtr)params->fParameters, 3);
    Param4_headerNames.fromParamAtIndex((PackagePtr)params->fParameters, 4);
    Param5_headerValues.fromParamAtIndex((PackagePtr)params->fParameters, 5);

    apr_interval_time_t timeout = (apr_interval_time_t)
    ((unsigned int)PA_GetLongParameter(params, 6));
    
    timeout = timeout ? timeout : 3000;
    
    char *command, *body;
    CUTF8String _command, _body;
    Param2_command.copyUTF8String(&_command);
    Param3_body.copyUTF8String(&_body);
    command = (char *)_command.c_str();
    body = (char *)_body.c_str();
    
    apr_status_t rc;
    
    PA_long32 ctxId = PA_GetLongParameter(params, 1);
    stomp_ctx *ctx = stomp_context_get(ctxId);
    
    if(ctx)
    {
        stomp_frame frame;
        
        apr_socket_timeout_set(ctx->connection->socket, timeout * 1000);
        
        frame.command = command;
        frame.body = _body.length() ? body : NULL;
        frame.body_length = _body.length(); //not using -1 (strlen)
        frame.headers = apr_hash_make(ctx->pool);
        
        bool withHeaders = false;
        
        if(Param4_headerNames.getSize() == Param5_headerValues.getSize())
        {
            CUTF8String headerName, headerValue;
            for(unsigned int i = 0; i < Param4_headerNames.getSize(); ++i)
            {
                Param4_headerNames.copyUTF8StringAtIndex(&headerName, i);
                Param5_headerValues.copyUTF8StringAtIndex(&headerValue, i);
                if(headerName.length())
                {
                    apr_hash_set(frame.headers, headerName.c_str(), APR_HASH_KEY_STRING, headerValue.c_str());
                    withHeaders = true;
                }
            }
        }
        if(!withHeaders)
        {
            frame.headers = NULL;
        }
        
        rc = stomp_write(ctx->connection, &frame, ctx->pool);
        
        PA_ReturnLong(params, -rc);
        
    }else
    {
        PA_ReturnLong(params, -1);
    }

}

void STOMP_Connect(PA_PluginParameters params) {
    
    C_TEXT Param1_host;
    
    Param1_host.fromParamAtIndex((PackagePtr)params->fParameters, 1);
    const char *hostname;
    CUTF8String _hostname;
    Param1_host.copyUTF8String(&_hostname);
    hostname = (const char *)_hostname.c_str();
    
    int port = PA_GetLongParameter(params, 2);
    
    apr_status_t rc;
    apr_pool_t *pool;
    stomp_connection *connection;
    
    rc = apr_pool_create(&pool, NULL);
    if (rc == APR_SUCCESS)
    {
        rc = stomp_connect(&connection, hostname, port, pool);
        if(rc == APR_SUCCESS)
        {
            PA_ReturnLong(params, stomp_context_add(connection, pool));
        }else
        {
            PA_ReturnLong(params, -rc);
        }
    }else
    {
        PA_ReturnLong(params, -rc);
    }
    
}

void STOMP_Disconnect(PA_PluginParameters params) {

    PA_long32 ctxId = PA_GetLongParameter(params, 1);
    stomp_ctx *ctx = stomp_context_get(ctxId);
    
    if(ctx)
    {
        PA_ReturnLong(params, stomp_disconnect(&ctx->connection));
        stomp_context_remove(ctxId);
    }else
    {
        PA_ReturnLong(params, -1);
    }
}
